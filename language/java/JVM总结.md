# JVM总结

## JVM&JRE&JDK

> JRE = JVM + 基础类库
>
> JDK = JRE + 编译工具 = JVM + 基础类库 + 编译工具

- JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。
- JRE：Java Runtime Environment，Java 运行环境，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。
- JVM：Java虚拟机

## Java内存区域

![](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/202204051512852.jpg)

### 程序计数器

> 线程私有，表示当前线程所执行的字节码的行号指示器。

- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

- 物理上是使用寄存器来实现的。

- 简单来说，记住下一条jvm指令的执行地址。

### 虚拟机栈

> 线程私有，虚拟机栈描述的是Java方法执行的线程内存模型。

![虚拟机栈](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/202204051449099.jpg)

- 每个线程运行时所需要的内存，成为虚拟机栈。
- 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存。
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。

栈内的元素是栈帧，一个栈帧是指每个方法运行时需要的内存，每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

#### 虚拟机栈中的元素

栈帧中存储**局部变量表**、**操作数栈**、**动态连接**、**方法返回地址**。

- **局部变量表(Local Variable Table)**是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。局部变量可以保存基本数据类型、对象引用、returnAddress类型（指向了一条字节码指令的地址）。
- **操作数栈**。会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者。
- **动态连接**。每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的**动态连接**。
- **方法返回地址**。方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的。

#### 一些问题

- **问题一：垃圾回收是否涉及栈内存？**

因为栈内存时一次次方法调用产生的栈帧内存，每一次方法调用完会自动出栈并回收，所以根本不需要进行垃圾回收。

- **问题二：栈内存是否越多越好？**

栈内存可以通过 -Xss 来设置，栈内存越大，占用空间的多，所能运行的线程数目变少。

- **问题三：方法内的局部变量是否线程安全？**

如果方法内的局部变量没有逃离方法的作用访问，它是线程安全的；如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全。

#### 栈内存溢出

> 抛出StackOverflowError异常

- 如果栈帧过多导致栈内存溢出
- 如果栈帧过大导致栈内存溢出

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；

如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。

### 本地方法栈

> 线程私有，与虚拟机栈的作用相似。

- 虚拟机栈为虚拟机执行Java方法(也就是字节码)服务。
- 本地方法栈为虚拟机使用到的本地(Native) 方法服务。
- -Xss 可以设置每个线程的堆栈大小

```java
protected native int hashCode();
```

### 堆

> 线程共享，用于存储对象实例。

- 线程共享，堆中的对象都需要考虑线程安全的问题
- 有垃圾回收机制

#### 堆内存溢出

> 抛出OutOfMemoryError异常。

- -Xmx 可以设置堆空间的最大内存
- 如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，会抛出异常

#### 堆内存诊断工具

- **jps**：查看当前系统中有哪些java进程。
- **jmap**：查看堆内存占用情况。
- **jconsole**：图形界面的，多功能监测工具，可以连续监测。
- **jvisualvm**：也是图形化界面，比jconsole多了堆Dump功能，可以分析堆中的内存对象。

### 方法区

> 线程共享，存储了每个类的信息（包括类的名称、方法信息、字段信息）、常量池、静态变量、JIT编译后的代码等。

**方法区（method area）**只是**JVM规范**中定义的一个概念，具体放在哪里，不同的实现可以放在不同的地方。

![](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/202204061232272.jpg)

- JDK1.6中方法区的内存结构

  类文件信息、类加载器、运行时常量池（包括StringTable串池）都放在永久代中

- JDK1.8中方法区的内存结构

  类文件信息、类加载器、运行时常量池放在元空间中，元空间直接在本地内存中

  StringTable放在堆中

#### 方法区溢出

- 如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。
- -XX :MaxMetaspaceSize=8m 来设置方法区大小

#### 运行时常量池

![](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/202204061236459.jpg)

- **常量池**就是在字节码中的一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。

- **运行时常量池**，常量池是*.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址
- **StringTable**是运行时常量池的一部分，存储储存字符串常量

#### StringTable

```java
// 常量池中的信息，都会被加载到运行时常量池中，这时a b ab都是常量池中的符号，还没有变为java字符串对象
// 等到具体执行到引用它的代码时，才进行生成对象。【也就是所谓的懒加载】
// StringTable["a","b","ab"]  ->  相当于是一个hash表
public class Demo1 {
	public static void main(String[] args) {
		String s1 = "a";// 懒加载的
		String s2 = "b";
		String s3 = "ab";

		String s4 = s1 + s2; // 原理 new StringBuilder().append("a").append("b").toString();
		System.out.println(s3 == s4); // false 因为s4是new出来的，所以是放在堆中，而s3是加载到常量池当中的，所以两者地址不一样，返回false
		
		String s5 = "a" + "b"; // 直接找到常量池中“ab”对象，所以s5直接从常量值中取值（javac在编译期间的优化）
		System.out.println(s3 == s5); // true
	}
}
```

- 常量池中的字符串仅是符号，第一次用到时才变为对象
- 利用串池（StringTable）的机制（本质是hash），来避免重复创建字符串对象
- 字符串变量拼接的原理是Stringbuilder（见上面的例子）
- 字符串常量拼接的原理是编译器优化（见上面的例子）
- 可以使用intern方法，主动将串池中不存在的字符串放入串池【s.intern()】

- StringTable也是会发生垃圾回收的，如果存放在永久代中，StringTable的垃圾回收效率会很低

- -XX:StringTableSize=200000 设置StringTable大小

## 垃圾回收

### 判断对象是否可以回收

#### 引用计数法

> 如果引用了对象，计数就+ 1

- 弊端：循环引用时候，导致两个对象都无法被释放

#### 可达性分析算法

> Java虚拟机采用可达性分析来探索所有存活的对象

扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到代表可以回收。

可以作为GC Root对象（主要为栈、方法区中饮用的对象）：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 本地方法栈中引用的对象
- 方法区中的类静态属性引用的对象；
- 方法区中常量引用的对象；

#### 四种引用

- **强引用**：普通使用的引用都是强引用，只有GC Root都不引用该对象，才会回收强引用对象
- **软引用**：GC Root指向软引用对象，软引用指向我们真正的对象，叫做软引用。**在垃圾回收后，内存仍然不足时会再次进行垃圾收集，此时会回收软引用所引用的对象**。
- **弱引用**：GC Root指向弱引用对象，弱引用指向我们真正的对象，叫做弱引用。**在垃圾回收时，无论内存是否充足，都会回收弱引用所引用的对象。**
- **虚引用**：必须配合引用队列使用，主要配合ByteBuffer使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存。最弱的引用，检测对象是否存活。

### 垃圾回收算法

#### 标记-清除算法

> 先采用标记确定可回收的对象，然后再根据标记清除内容。

- 优点 : 速度快。

- 缺点 : 容易产生大量的内存碎片，无法满足大对象的内存分配。 

#### 标记-整理算法

> 先进行标记，将不被回收的内存空间进行移动排序。

- 优点：不会产生内存碎片。
- 缺点：效率低，要进行内存的移动，且要进行程序内存地址的改变。

#### 复制算法

> 将内存分为等大小的两个区域，每一次只使用一块区域。当进行垃圾回收时，将不被回收的对象从FROM放入TO区域，清扫FROM区域，并交换FROM和TO的位置。

- 优点：不会产生内存碎片

- 缺点：占用双倍内存，可用内存减半

### 分代回收理论

> 将内存分为新生代和老年代。新生代处理
>
> 新生代分为三个区域分别是Eden、Survivor From、Survivor To，他们的比例是8：1：1

#### 回收流程

- 对象首先分配在Eden区，每次垃圾回收之前，Survivor To区域一定是空的。

- 新生代空间不足时，触发Minor GC（引发短暂的STW），Eden和From存活的对象使用复制算法复制到To中，存活对象的年龄 + 1 并且交换To和From。当对象寿命超过阈值（最大15次，不一定是15次）时，会晋升至老年代。（Marked Word里面有一个字段存储age，为4位）

- 如果新生代老年代中的内存都满了，会先尝试触发Minor GC，如果空间仍然不足，触发Full GC（同时回收新生代和老年代的内存）。Full GC的STW的时间更长。

- 当遇到一个较大的对象时，就算新生代的**Eden为空**，也无法容纳该对象时，会将该对象**直接晋升为老年代**。

### 垃圾回收器

#### Serial 收集器

> 串行的新生代收集器。

- 单线程、简单高效
- 采用复制算法
- 收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）

#### CMS收集器

> 一种以获取最短响应时间为目标的老年代收集器。CMS收集器的内存回收过程是与用户线程一起并发执行的。

- 特点

基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片

- 应用场景

适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务。

- 运行过程
  - **初始标记**：标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题
  - **并发标记**：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行
  - **重新标记**：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题
  - **并发清除**：对标记的对象进行清除回收（标记清除算法）

#### G1收集器

> Garbage First，JDK 9以后默认使用，而且替代了CMS 收集器

- 适用场景
  - 同时注重吞吐量和低延迟（响应时间）
  - 超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域（Region），每个区域都可以作为Eden、Survivor、Old、H
  - 整体上是标记-整理算法，两个区域之间是复制算法
- G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。

## 类加载

### 类加载阶段

#### 1. 加载

> 将类的字节码载入方法区中

#### 2.链接-验证

> 验证类是否符合Java规范，安全性检查

比如修改类字节码的CAFEBABE，就会报错

#### 3.链接-准备

> 为static变量分配空间，设置默认值

#### 4. 链接-解析

> 将常量池中的符号引用解析为直接引用

准备阶段之后，常量池中的引用还只是一个占位符，还不知道具体的地址位置

但是经过初始化和解析之后，常量池中的引用是直接引用

#### 5.初始化

> 初始化即调用<cinit>()V，虚拟机会保证这个类的【构造方法】的线程安全

总的来说，类初始化是懒惰的，这里的初始化都是指的类加载，而不是new一个对象，是新建一个class对象

### 双亲委派机制

#### JVM预定义的三种类型类加载器

- 启动（Bootstrap）类加载器
- 扩展（Extension）类加载器
- 应用程序（Application）类加载器
- CustomClassLoader（用户自定义类加载器）

#### 双亲委派机制描述

> 每一个类都有一个对应它的类加载器。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。

某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归:

- 如果父类加载器可以完成类加载任务，就成功返回；
- 只有父类加载器无法完成此加载任务时，才自己去加载。

#### 委托机制的意义

- 防止重复加载同一个.class字节码

- 保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。