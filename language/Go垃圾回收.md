# Golang中GC回收机制

[Golang中GC回收机制三色标记与混合写屏障](https://www.bilibili.com/video/BV1wz4y1y7Kd)

[[典藏版]Golang三色标记、混合写屏障GC模式图文全分析](https://www.jianshu.com/p/4c5a303af470)

## Go V1.3 标记-清除算法

### 主要步骤

此算法主要有两个主要的步骤：

- 标记(Mark phase)
- 清除(Sweep phase)

![标记清除主要步骤](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220224191213.jpg)

**第一步**，STW(stop the world), 找出不可达的对象，然后做上标记。

**第二步**, 开始标记，程序找出它所有可达的对象，并做上标记。

**第三步**, 标记完了之后，然后开始清除未标记的对象。

**第四步**, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。

所以Go V1.3版本之前就是以上来实施的, 流程是

![标记清除](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220224190001.webp)

Go V1.3 做了简单的优化,将STW提前, 减少STW暂停的时间范围.如下所示：

![标记清除](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220224190029.webp)

**这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序** 。

### 缺点

- STW，stop the world；让程序暂停，程序出现卡顿 **(重要问题)**。
- 标记需要扫描整个heap
- 清除数据会产生heap碎片

Go是如何面对并这个问题的呢？接下来Go V1.5版本 就用**三色并发标记法**来优化这个问题.

## GoV1.5 三色标记法

### 定义

- 黑色：检测到有被引用，并且已经遍历完它所有直接引用的对象或者属性
- 白色：还没检测到有引用的对象（检测开始前，所有对象都是白色，检测结束后，没有被引用的对象都是白色，会被清查掉）
- 灰色：检测到有被引用，但是他的属性还没有被遍历完，等遍历完后也会变成黑色

如果不使用STW，这种方式会造成标记不准确的问题：

- **一个白色对象被黑色对象引用**

- **白色对象又被某个灰色（或者上级有灰色对象）对象取消引用。**

因此如果想摘除 STW，那就得规避掉上面这个场景出现。解决方法是：使用 **插入屏障** 和 **删除屏障**。（场景案例可以看[典藏版文档](https://segmentfault.com/a/1190000022030353)）

### 插入屏障

在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)。

### 删除屏障

被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。

## GoV1.8 三色标记法-混合写屏障机制

### V1.5的缺点

插入写屏障和删除写屏障的短板：

- 插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；（因为插入写屏障只运用于堆上）
- 删除写屏障：回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。

Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。

### 混合写屏障规则

- GC开始将栈上的对象全部扫描并标记为黑色，GC期间，任何在栈上创建的新对象，均为黑色。
- 被删除的对象标记为灰色
- 被添加的对象标记为灰色。

 Golang中的混合写屏障满足`弱三色不变式`，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。

（场景案例可以看[典藏版文档](https://segmentfault.com/a/1190000022030353)）

## 总结

GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。

GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通。

GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。

