 # 堆排序

- 参考王道7.4.2-堆排序

## 堆的定义

> 堆就是用数组实现的二叉树，所以它没有使用父指针或者子指针。

### 堆的常用方法

- 构建优先队列
- 支持堆排序
- 快速找出一个集合中的最小值（或者最大值）

### 最大堆和最小堆

- 在最大堆中，父节点的值比每一个子节点的值都要大。

- 在最小堆中，父节点的值比每一个子节点的值都要小。

## 堆的实现

```java
import java.util.*;
class Main { 
	// 调整
    static void adjust(int arr[], int k, int len) {
        int temp = arr[k];
        for (int i = 2 * k + 1; i < len; i = i * 2 + 1) {
            if (i < len - 1 && arr[i] < arr[i + 1]) i ++;
            if (temp > arr[i]) break;
            else {
                arr[k] = arr[i];
                k = i;
            }
        }
        arr[k] = temp;
    }

    // 建堆
    static void buildMaxHeap(int arr[]) {
        for (int i = arr.length / 2 - 1; i >= 0; i --) {
            adjust(arr, i, arr.length);
        }
    }

    // 堆排序
    static void heapSort(int arr[]) {
        buildMaxHeap(arr);
        for (int i = arr.length - 1; i >= 0; i --) {
            int temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;
            
            adjust(arr, 0, i);
        }
    }
    
    public static void main(String[] args) {
        int[] nums = new int[]{53, 17, 78, 9, 45, 65, 87, 32};
        heapSort(nums);
        for (int i : nums) {
            System.out.print(i + " ");
        }
        System.out.println();

    }
}
```

## 复杂度分析

- 空间效率：仅使用常数个辅助单元，空间复杂度位`O(1)`。
- 时间效率：建堆时间复杂度`O(n)`（可以用数学的方式推导出来），之后有`n-1`次向下调整操作，每次调整时间复杂度位`O(h)`（h是堆的高度）。因此最好最坏和平均条件下，堆排序的时间复杂度位`O(nlogn)`。
- 稳定性：不稳定排序，因为每次会把最后面的元素提到前面去。

