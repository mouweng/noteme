# 内存管理

 ## 内存管理基本原理和要求

### 内存管理的作用

- **内存空间的分配和回收**：由操作系统完成，对程序员是透明的。
- **地址转换**：程序的逻辑地址和内存的物理地址不是一致的，需要地址转换。
- **内存空间的扩充**：利用虚拟内存技术，在逻辑上扩充内存。
- **存储保护**：保证程序在各自的存储空间运行，互不干扰。

### 程序的装入和链接

![程序的装入和链接](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228102105.JPG)

创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序：

- 编译：由编译器将用户源代码编译成目标模块
- 链接：由链接程序将目标模块和库函数链接在一起，形成一个完整的装入模块
- 装入：由装入程序将装入模块装入内存

动态运行时装入：装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是在程序真正执行时才转换。这种方式需要一个重定位寄存器支持。这样做可以将程序分配到不连续的存储区，在运行前只装入部分代码即可运行，然后在运行期间动态申请分配内存，可以向用户提供一个比存储空间更大的地址空间。

### 逻辑地址空间与物理地址空间

- 逻辑地址：编译后，每个目标模块从0开始编址，不同进程可以拥有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置。程序员和用户程序只需要知道逻辑地址即可，这对他们来说是透明的。

- 物理地址：内存中地址转换的最终地址，进程运行时执行指令和访问数据，都要通过物理地址存取。

当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为**地址重定位**。

## 连续分配管理方式

> 为用户程序分配一个连续的内存空间。

### 单一连续分配

只用于单用户、单任务的操作系统。

### 固定分区分配

可用于多道程序的最简单的存储分配，将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。

### 动态分区分配

在进程装入内存时，根据进程的大小动态的建立分区，因此分区的大小和数目是可变的。

动态分配策略：

- 首次适应算法。按地址递增次序，找到大小能满足要求的第一个空闲分区。
- 最佳适应算法。按容量递增次序，找到大小能满足要求的第一个空闲分区。
- 最坏适应算法。按容量递减次序，找到大小能满足要求的第一个空闲分区。
- 循环首次适应算法。从上次查找结束的位置继续开始查找

## 非连续分配管理方式

> 非连续分配允许一个程序分散地装入不相邻的内存分区。根据分区的大小是否固定，分为分页存储管理方式和分段存储管理方式。

非连续可以将作业分散的分配在内存的各个区域，当然也需要额外的空间去存储他们的索引，使得非连续分配方式的存储密度低于连续存储方式。

### 基本分页存储管理方式

> 把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。进程运行时按块申请空间并执行，只会在最后一个块才会产生碎片。

#### 1）分页

- **页面和页面大小**。页面大小应该是2的整数幂，且大小应该适中。太大会使得页面碎片增多；太小页表就会过长。

- **地址结构**。前一部分为页号P，后一部分为页内偏移量W。地址长度为32位，其中0～11为页内地址，即每页大小为`4KB`；12～31位为页号，地址空间最多允许`pow(2,20)`页。

    ![分页地址结构](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228155810.JPG)

- **页表**。为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程分配一张页表，页表一般放在内存中。（页表的页表项和地址结构式不一样的，第一部分都是页号，但是页表项的第二部分是内存中的块号，而地址结构的第二部分是页内偏移）。

    ![页表的作用](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228155833.JPG)

#### 2）基本地址变换机构

> 将逻辑地址转换为物理地址，借助页表实现地址转换。

![分页地址变换机构](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228155851.JPG)

在系统中设置一个页表寄存器，存放页表在内存的始址F和页表长度M。进程未执行时，页表的始址和长度存放在进程控制块中，当进程执行时，将其加载到寄存器当中。

#### 3）快表

> 在地址变换机构中增设一个具有并行查找能力的高速缓冲存储器，称为快表。

解决地址转换两次访问内存，访存速度低下的问题。

![具有快表的地址变换机构](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228160349.JPG)

快表有效性基于局部性原理。有些处理机设计为快表和慢表同时查找，若在快表中查找成功泽终止慢表的查找。

#### 2）两级页表

二级页表实际上是在原有页表的基础上在加一层页表，相当于二次索引。

![二级页表逻辑地址空间的格式](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228162158.JPG)

![二级页表结构示意图](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228162219.JPG)

多级页表解决了当逻辑地址空间过大时，页表长度大大增加的问题。而采用多级页表时，一次访盘需要多次访问内存甚至磁盘，会大大增加一次访存的时间。

#### 5）总结

可以把分页的主存想像成一本笔记本，被划分为各个页。每一个章节可以不用连续存储在同一块，而是分散的存储在笔记本的各个页，用目录（页表）去做管理。

### 基本分段存储管理方式

> 考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长以及动态链接等多方面的需要。

#### 1）分段。

>  段式管理方式按照用户进程中的自然段划分逻辑空间。

例如，用户进程由主程序、两个字程序、栈和一段数据组成，于是把这个进程划分为5段。每段从0开始编址，并分配一段连续的地址空间。



在高级程序设计语言中，分段工作由编译程序完成。

#### 2）段表

> 用于实现逻辑地址到物理地址的映射。

![段表的内容](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228150510.JPG)

每个进程都有一张逻辑空间和内存空间映射的段表，段表记录内存中的始址和长度。

![利用段表实现逻辑段到物理空间的映射](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228150723.JPG)

#### 3）地址变换机构

为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置段表寄存器，用于存放段表始址F和段表长度M。

![分段系统的地址变换过程](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228150753.JPG)

### 分段和分页的区别

| 分页                                                         | 分段                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 地址空间是一维的。只需给出一个整数就能确定对应的物理地址。（页大小固定，可以计算出具体的页） | 地址空间是二维的。需要给出段号和段内偏移量。（因为段的长度是不确定的） |
| 页的大小固定且由系统决定                                     | 段的长度却不固定，决定于用户所编写的程序。                   |
| 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。 | 段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 |

### 段页式存储管理方式

> 在段页式系统中，作业的地址空间首先被划分为若干逻辑段，每段有自己的段号，然后将每段分成若干大小固定的页。对内存的分配以存储块为单位。

![段页式管理方式](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228153423.JPG)

为了实现地址变换，系统为每个进程建立一张段表，每个分段有一张页表。

- 段表表项中包括段号，页表长度和页表始址
- 页表表项中包括页号和块号
- 在一个进程中，段表只有一个，而页表可能有多个

![段页式系统的地址变换机构](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228153749.JPG)

进行一次访问实际上需要访问三次主存。段页式管理的地址空间也是二维的。

## 虚拟内存

### 局部性原理

- **时间局部性**。某个数据被访问，不久后该数据可能再次被访问。
- **空间局部性**。某个数据被访问，可能其周围空间的数据也会被访问。

### 虚拟存储器的定义

> 基于局部性原理，在程序装入时，将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。当访问的信息不在内存时，发生中断，由操作系统进行页面置换，将需要的内容调入内存。这样，系统好像为用户提供了一个比实际内存大很多的存储器。

作业一次性装入内存并在内存中驻留：会导致部分作业太大无法装入内存，以及大量作业运行内存不足以容纳所有作业，会造成资源的浪费。

### 请求分页管理方式

> 建立在基本分页系统的基础上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。

#### 页表机制

![请求分页页表项目](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228180845.JPG)

- **状态位**：用于指示该页是否已调入内存
- **访问字段**：用于记录一段时间内访问次数
- **修改位**：标识该页调入后是否被修改过
- **外存地址**：指出该页在外存上的地址，调入该页时所需

#### 缺页中断机制

请求分页系统中，如果要访问的页面不存在内存中，便产生一个缺页中断，请求操作系统将所缺的页面调入内存，此时缺页的进程阻塞（调页完成唤醒）。

#### 地址变换机构

在分页系统地址变换的基础上，增加部分功能。

![请求分页地址变换过程](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228180845.JPG)

### 页面置换算法

> 进程运行时，若其访问的页面不存在内存中而需将其调入内存，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘对换区。

#### 1.最佳置换算法（OPT）

淘汰在最长时间内不被访问的页面。这是一种理想的算法。

#### 2.先进先出置换算法（FIFO）

淘汰最早进入内存的页面。

#### 3.最近最久未使用（LRU）

淘汰最近最久未使用的页面。

#### 4.时钟置换算法（CLOCK）

当页面被访问 (读或写) 时，把该页面放到链表的尾端。再使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

![时钟置换算法](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220228175818.png)