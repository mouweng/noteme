# 系统调用

- [彻底搞懂系统调用](https://www.eet-china.com/mp/a77607.html)
- [Linux系统调用详解（实现机制分析）--linux内核剖析（六）](https://blog.csdn.net/gatieme/article/details/50779184)
- [Linux系统调用(syscall)原理](http://gityuan.com/2016/05/21/syscall/)

## 1.什么是系统调用？

>  在用户空间和内核空间之间，有一个叫做Syscall(系统调用, system call)的中间层，是连接用户态和内核态的桥梁。

在应用程序开发过程中经常会进行IO设备的操作，比如磁盘的读写，网卡的读写，键盘，鼠标的读入等，大多数应用开发人员使用高级语言进行开发，例如C，C++，java，python等，这些高级语言都提供了标准库或者API去操作IO设备，不过标准库或者API最终还是通过系统调用来实现操作IO设备的，系统调用是操作系统提供的，它是操作系统内核的一部分。

系统调用封装了对硬件操作的所有细节，而标准库或者SDK又在系统调用的基础上做了高度抽象的封装和优化，因此使得应用程序开发人员的日子好过多了，开发效率也提高了不少。

系统调用需要进行模式切换，而每个完整的应用程序都有两个栈，一个用户栈，一个内核栈，这两个栈是独立的，用户栈在用户空间，内核栈在内核空间，因此切换模式时，栈也得切换。

因此我们可以将系统调用的执行步骤分为三步：1.执行前的准备工作。2.执行处理程序（处理函数）。3.执行后的善后工作，当然内核模式切换和栈切换就是1和3的工作了，这里的三步都是在内核模式下执行的，如下图所示：

![](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/202204171439732.png)

从上图得知，执行一个系统调用很复杂，需要干很多的活，Linux的编译器提供了很多共享库（so文件）来提供系统调用，例如Linux的glibc库就提供了文件操作相关的系统调用，例如下面的代码：

```c
int read(int fd,void *buf,int count);//读文件数据
int write(int fd,const void *buf,int couint);//写文件数据
int open(const char * pathname,int flags,mode_t mode);//打开文件
```

每个操作系统都提供它各自的系统调用，那么写一段C代码怎样能做到跨操作系统呢?答案是C语言标准库，C语言标准库的目的就是让开发人员写一段C代码，这些C代码使用的是C标准库，那么这段代码不需要进行任何修改就可以跨操作系统：

![](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/202204171441124.png)

## 2.系统调用的作用

系统调用在用户空间进程和硬件设备之间添加了一个中间层。该层主要作用有三个：

- **它为用户空间提供了一种统一的硬件的抽象接口。**比如当需要读些文件的时候，应用程序就可以不去管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型。
- **系统调用保证了系统的稳定和安全。**作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确地使用硬件设备，窃取其他进程的资源，或做出其他什么危害系统的事情。
- **每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共接口，也是出于这种考虑。**如果应用程序可以随意访问硬件而内核又对此一无所知的话，几乎就没法实现多任务和虚拟内存，当然也不可能实现良好的稳定性和安全性。在Linux中，系统调用是用户空间访问内核的惟一手段；除异常和中断外，它们是内核惟一的合法入口。

## 3.系统调用的实现？

以操作系统Linux（2.5以前），处理器为Inter IA-32为例，看看fork这个系统调用是怎么实现的，其它的Linux系统调用类似，整体过程如下图：

![](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/202204171447902.png)

上图为系统调用涉及到的9个步骤：

1. 应用程序调用linux库提供的fork函数，发起一个fork系统调用，这个系统调用的目的是创建一个子进程，这个子进程拷贝一份父进程的虚拟进程空间。

2. fork函数的第一步就是将2放入寄存器eax,每个系统调用都有一个编号，2就是fork系统调用的编号，eax是默认用于传递系统调用编号的寄存器。

   如果系统调用有参数，则将参数传入到如下的寄存器EBX，ECX，EDX，ESI，EDI，EBP，可以看出系统调用最多支持6个参数，fork系统调用没有参数。

   fork函数的第二步就是执行中断指令int 0x80,中断指令int用于发送中断信号给处理器，0x80为中断向量号，这个向量号是系统调用中断处理程序专用。

   int指令同时也会将模式从用户态切换到内核态，用户栈切换到内核栈，同时会将当前被中断的应用程序，中断时的寄存器内容入栈（SS，ESP，EFLAGS，CS，EIP），这里的入栈指的是入内核栈（每一个应用程序都一个用户栈和内核栈）。

   整体来看，2步骤的汇编代码如下：

   ```c
   push EAX,2;//设置fork系统调用的系统调用编号
   mov EBX,arg1;//可选，参数1
   mov ECX,arg1;//可选，参数2
   mov EDX,arg1;//可选，参数3
   mov ESI,arg1;//可选，参数4
   mov EDI,arg1;//可选，参数5
   mov EBP,arg1;//可选，参数6
   int 0x80;//发送系统调用中断信号
   ```

3. 处理器执行完当前的指令后，会检查处理器的中断引脚，发现有中断信号，然后检查状态寄存器（EFLAGS)，发现中断屏蔽IF标志是打开的(系统调用中断信号不会被屏蔽)，处理器根据中断信号，分析出中断向量号，然后根据中断向量号去查找中断描述符表，找到了该中断向量号对应的中断处理程序。

4. 操作系统跳转到中断处理程序，然后开始执行中断处理程序，0x80对应的中断处理程序是系统调用中断处理程序（system_call）。

   该中断处理程序首先会将EAX，EBX，ECX，EDX，ESI，EDI，EBP这几个寄存器入栈，之所以入栈，就是为了防止后续的工作覆盖这些寄存器，核心汇编指令如下：

   ```c
   push EAX;
   push EBX;
   push ECX;
   push EDX;
   push ESI;
   push EDI;
   push EBP;
   ```

5. 系统调用中断处理程序紧接着根据系统调用号(这里就是fork系统调用号即2)，去系统调用表进行查找，可以找到该系统调用号对应的处理程序(也可以叫处理函数),Linux操作系统的系统处理函数一般以sys开头，fork的系统处理函数就是sys_fork。
6. 找到了系统处理函数后，开始执行该函数，处理函数可以从内核栈中获取函数的参数，函数执行完成后，函数的返回值，默认采用EAX寄存器进行返回。
7. (&8)系统处理函数执行完成后，回到了系统调用中断处理程序，中断处理程序执行iret指令，iret指令负责从内核态切换到用户态，将内核态入栈的寄存器数据出栈到SS，ESP，EFLAGS，CS，EIP这几个寄存器，然后跳转到系统调用处。
8. 系统调用fork返回到应用程序。

