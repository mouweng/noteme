# Redis面试总结

- [Redis 面试总结](https://dunwu.github.io/db-tutorial/nosql/redis/redis-interview.html#redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)

## Redis 数据类型

- String：常用于 KV 缓存

- Hash：存储结构化数据，如：产品信息、用户信息等。

- List：存储列表，如：粉丝列表、文章评论列表等。可以通过 lrange 命令进行分页查询。

- Set：存储去重列表，如：粉丝列表等。可以基于 set 玩儿交集、并集、差集的操作。例如：求两个人的共同好友列表。

- Sorted Set：存储含评分的去重列表，如：各种排行榜。

除此以外，还有 Bitmaps、HyperLogLogs、GEO、Streams 等高级数据类型。

## Redis 内存淘汰机制

### 过期的数据的删除策略

- 定期删除：每隔一段时间，会扫描expires字典中一定数量的key，清除其中的过期key。
- 惰性删除：当访问一个Key的时候才会去判断Key是否已经过期（对CPU友好，对内存不太友好）

### 内存淘汰机制

- **`noeviction`** - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。
- **`allkeys-lru`** - 在所有空间中，优先移除最近未使用的 key。
- **`allkeys-random`** - 在所有空间中，随机移除某个 key。
- **`volatile-lru`** - 在设置了过期时间的键空间中，优先移除最近未使用的 key。
- **`volatile-random`** - 在设置了过期时间的键空间中，随机移除某个 key。
- **`volatile-ttl`** - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。

### 如何选择内存淘汰机制

- 如果数据呈现幂等分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 `allkeys-lru`。
- 如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 `allkeys-random`。
- `volatile-lru` 策略和 `volatile-random` 策略适合我们将一个 Redis 实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个 Redis 实例来达到相同的效果。
- 将 key 设置过期时间实际上会消耗更多的内存，因此我们建议使用 `allkeys-lru` 策略从而更有效率的使用内存。

## Redis 持久化方式

> Redis 支持两种持久化方式：RDB 和 AOF。

### RDB

> RDB 即某一时刻的二进制数据快照。

Redis 会周期性生成 RDB 文件。

生成 RDB 流程：Redis fork 一个子进程，负责生成 RDB；生成 RDB 采用 Copy On Write 模式，此时，如果收到写请求，会在原副本上操作，不影响工作。

RDB 只能恢复生成快照时刻的数据，之后的数据无法恢复。生成 RDB 的资源开销高昂。RDB 适合做冷备。

### AOF

> AOF 会将写命令不断追加到 AOF 文本日志末尾。

AOF 丢数据比 RDB 少，但文件会比 RDB 文件大很多。一般，AOF 设置 `appendfsync` 同步频率为 **`everysec`** 即可。

### RDB or AOF

建议同时使用 RDB 和 AOF。用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。

## Redis 事务

**Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去**。

- Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。
- 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。

你可以将 Redis 中的事务就理解为 ：Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。

Redis 有天然解决这个并发竞争问题的类 CAS 乐观锁方案：每次要**写之前，先判断**一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。

##  Redis 高并发

### 单线程

Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis 单机吞吐量也很高，能达到几万 QPS。

Redis 单线程模型，依然有很高的并发吞吐，原因在于：

- Redis 读写都是内存操作。
- Redis 基于**非阻塞的 IO 多路复用机制**，同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。
- 单线程，避免了线程创建、销毁、上下文切换的开销，并且避免了资源竞争。

### 扩展并发吞吐量、存储容量

Redis 的高性能（扩展并发吞吐量、存储容量）通过主从架构来实现。

Redis 集群采用主从模型，提供复制和故障转移功能，来保证 Redis 集群的高可用。通常情况，一主多从模式已经可以满足大部分项目的需要。根据实际的并发量，可以通过增加节点来扩展并发吞吐。

一主多从模式下，主节点负责写操作（单机几万 QPS），从节点负责查询操作（单机十万 QPS）。

进一步，如果需要缓存大量数据，就需要分区（sharding）。Redis 集群通过划分虚拟 hash 槽来分片，每个主节点负责一定范围的 hash 槽。当需要扩展集群节点时，重新分配 hash 槽即可，redis-trib 会自动迁移变更 hash 槽中所属的 key。

### Redis 集群数据一致性

Redis 集群基于复制特性实现节点间的数据一致性。

##  Redis 复制

1. 从服务器启动，向主服务器发送SYNC命令，主服务器保存快照，并将保存快照期间接受到的命令缓存起来，然后把快照文件和缓存时的命令一并发送给从服务器。
2. 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，再执行缓存时的命令
3. 主服务器每一次执行写命令，就向从服务器发送相同的写命令（异步，故是乐观复制）

## Redis 哨兵

Redis 的高可用是通过哨兵来实现（Raft 协议的 Redis 实现）。Sentinel（哨兵）可以监听主服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。

由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。

![sentinel](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220310004133.png)

## 缓存雪崩、缓存穿透、缓存击穿

### 缓存雪崩

> 缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。

- 热点缓存永不失效
- 随机设置缓存的失效时间

### 缓存击穿

> 并发请求某一个失效的缓存

### 缓存穿透

> 大量请求缓存中没有，数据库中也没有的数据

- 缓存无效key
- 布隆过滤器（如果某个值在布隆过滤器里面没有，则一定没有；如果在布隆过滤器有，他也不一定存在）

