# Redis缓存一致性

- [认识 MySQL 和 Redis 的数据一致性问题](http://learn.lianglianglee.com/%E6%96%87%E7%AB%A0/%E8%AE%A4%E8%AF%86%20MySQL%20%E5%92%8C%20Redis%20%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.md)
- [Redis与DB的数据一致性解决方案（史上最全）](https://www.cnblogs.com/crazymakercircle/p/14853622.html)

## 数据一致性问题

> “数据一致”一般指的是：缓存中有数据，缓存的数据值 = 数据库中的值。

缓存系统适用的场景就是非强一致性的场景，它属于CAP中的AP。CAP理论作为分布式系统的基础理论，最多满足其中的两个特性，无法同时满足CAP。

- 一致性（**C**onsistency）
- 可用性（**A**vailability）
- 分区容错性（**P**artition tolerance）

⚠️我们能放入缓存的数据本就不应该是实时性、一致性要求超高的。

## 新增数据

> 新增数据始终是处于”数据一致“的状态，**不会发生数据不一致性问题**

- **新增数据时** ，写入数据库；

- **访问数据时**，缓存缺失，查数据库，更新缓存。

![⚠️](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/202203311418612.jpg)

## 更新数据

### 存在问题

> 更新（修改/删除）数据时 ，会有个时序问题：**更新数据库与删除缓存的顺序**。在这个过程中容易发生数据不一致问题。⚠️

- 无并发请求下，其中一个操作失败的情况
- 并发请求下，其他线程可能会读到旧值

接下来，我们针对有/无并发场景，进行分析并使用不同的策略。

### 无并发情况

#### 问题

无并发请求下，在更新数据库和删除缓存值的过程中，因为操作被拆分成两步，那么就很有可能存在“步骤 1 成功，步骤 2 失败” 的情况发生。

- **先删除缓存，再更新数据库**存在的问题

​		删除缓存成功，更新数据库失败 ➡️ 请求无法命中缓存，读取数据库旧值

- **先更新数据库，再删除缓存**存在问题

​		更新数据库成功，删除缓存失败 ➡️ 请求命中缓存，读取缓存旧值

#### **解决策略1:消息队列+异步重试**

无论使用哪一种执行时序，可以在执行步骤 1 时，将步骤 2 的请求写入消息队列，当步骤 2 失败时，就可以使用重试策略，对失败操作进行 “补偿”。

1. 把要删除缓存值或者是要更新数据库值操作生成消息，暂存到消息队列中（例如使用 Kafka 消息队列）；
2. 当删除缓存值或者是更新数据库值操作成功时，把这些消息从消息队列中去除（丢弃），以免重复操作；
3. 当删除缓存值或者是更新数据库值操作失败时，执行失败策略，重试服务从消息队列中重新读取（消费）这些消息，然后再次进行删除或更新；
4. 删除或者更新失败时，需要再次进行重试，重试超过的一定次数，向业务层发送报错信息。

![消息队列+异步重试](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/202203311433706.jpg)

#### **解决策略2:消息队列+ binlog 变更日志**

通过数据库的 binlog 来异步淘汰 key，利用工具(canal)将 binlog 日志采集发送到 MQ 中，然后通过 ACK 机制确认处理删除缓存。

### 高并发情况

#### 问题

在高并发场景下，由于数据库层面的读写并发，会引发的数据库与缓存数据不一致的问题（本质是后发生的读请求先返回了）

- **先删除缓存，再更新数据库**存在的问题

![](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/202203311443954.jpg)

假设线程 A 删除缓存值后，由于网络延迟等原因导致未及更新数据库，而此时，线程 B 开始读取数据时会发现缓存缺失，进而去查询数据库。而当线程 B 从数据库读取完数据、更新了缓存后，线程 A 才开始更新数据库，此时，会导致缓存中的数据是旧值，而数据库中的是最新值，产生“数据不一致”。其本质就是，本应后发生的“B 线程-读请求” 先于 “A 线程-写请求” 执行并返回了。

- **先更新数据库，再删除缓存**存在的问题✔️（优先使用）

如果线程 A 更新了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。其本质也是，本应后发生的“B 线程-读请求” 先于 “A 线程-删除缓存” 执行并返回了。

![](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/202203311446981.jpg)

- **延时双删**存在问题

> 为了解决**先删除缓存，再更新数据库**存在的问题，提出了延迟双删的策略。

在线程 A 更新完数据库值以后，让它先 sleep 一小段时间，确保线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程 A 再进行删除。后续，其它线程读取数据时，发现缓存缺失，会从数据库中读取最新值。

 ```redis
 redis.delKey(X)
 db.update(X)
 Thread.sleep(N)
 redis.delKey(X)
 ```

sleep 时间：在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进行估算。

#### 解决策略1:消息队列+ binlog 变更日志

通过数据库的 binlog 来异步淘汰 key，利用工具(canal)将 binlog 日志采集发送到 MQ 中，然后通过 ACK 机制确认处理删除缓存。

#### 解决策略2:加锁

更新数据时，加写锁；查询数据时，加读锁 保证两步操作的“原子性”，使得操作可以串行执行。

## 总结

- 新增数据不存在数据一致性问题。

- 更新数据容易出现数据一致性问题，且分为非并发和并发两种情况。

- 更新数据时解决数据一致性的套路
  		1.先更新数据库，再删除缓存
   
   2.为了保证删除缓存成功， 使用binlog + 消息队列进行异步删除缓存

