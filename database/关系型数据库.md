# 关系型数据库面试题

- [DB-TUTORIAL（关系型数据库面试题）](https://dunwu.github.io/db-tutorial/sql/common/sql-interview.html#%E4%B8%80%E3%80%81%E7%B4%A2%E5%BC%95%E5%92%8C%E7%BA%A6%E6%9D%9F)

## 一、索引

> 索引是对数据库表中一或多个列的值进行排序的结构，是帮助数据库高效查询数据的数据结构。

### 1.1 索引的优缺点

- 优点：加速查询、排序、分组的速度；
- 缺点：索引需要占用额外的物理空间；写操作会更新索引导致速度减慢；太多的索引会增加查询优化器的选择时间；

### 1.2 索引使用原则

✔ 什么情况**适用**索引：

- 表经常进行 `SELECT` 操作；
- 表的数据量比较大；
- 列名经常出现在 `WHERE` 或连接（`JOIN`）条件中
- 外键要建立索引
- 增大索引选择性：索引应该建立在区分度高的字段上（比如性别字段选择性很低）

❌ 什么情况**不适用**索引：

- **频繁写操作**（ `INSERT`/`UPDATE`/`DELETE` ）- 需要更新索引空间；
- **非常小的表**：直接全表扫描更高效；
- 列名不经常出现在 `WHERE` 或连接（`JOIN`）条件中 - 索引就会经常不命中，没有意义，还增加空间开销。
- 对于特大型表，建立和使用索引的代价将随之增长。可以考虑使用分区技术或 Nosql。
- 避免重复索引，如果已经有a索引，现在要加（a,b）索引，没必要加，在原先基础上修改。

### 1.3 索引的类型

> 从物理存储上划分

- 聚簇索引

一般是主键上的索引(只有一个)，叶子节点存储一整行数据信息，维护代价很高。查询效率高，不需要二次查询。

- 非聚簇索引（辅助索引）

不一定是主键上的索引(可以有多个)，叶子节点只存储主键信息。需要二次查询，在非聚簇索引上检索到主键后，还要继续在聚簇索引上查找，IO次数比聚簇索引要多。

> 实现方式来划分

- B+树索引

B+树是大多数存储引擎的默认索引类型，可以用作范围查询、模糊查询、比较、排序。

- 哈希索引

哈希索引使用Hash表来作为底层结构，不可以用作范围查询、模糊查询、比较、排序，查询速度比较快O(1)，而B+树是O(logn)，在InnoDB存储引擎中“自适应哈希索引“功能，当某个值被频繁索引会在B+树索引的基础上建立一个Hash索引。

### 1.4 索引的数据结构

#### B+树

> 是为磁盘存储设计的一种平衡多叉查找树，平衡因子为0。

![B+树](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220307190228.png)

- 特性
    - 非叶子节点不存储数据，叶子节点数据用链表连接，按照key从左到右排列
- **操作**
    - 查找：在每个节点上进行二分查找，找到key所在的指针，递归直至找到叶子节点
    - 插入/删除/更改：会破坏树的平衡性，在插入删除后，要重新维护B+树（分裂、合并、旋转），开销大
- 对比B树优势
    - 查询性能稳定，所有查询都要找到叶子节点
    - 叶子节点有链表相连，便于范围查询和排序
    - 非叶子节点只存储主键，单一节点存储的元素更多，更矮胖，查询I/O次数减少
- 对比红黑树/AVL树的优势
    - B+树相对于二叉树更加矮胖，有更少的IO次数

#### 哈希

> 哈希索引使用Hash表作为底层结构。

- 只能用作等值查询，不可以用作范围查询（`WHERE price > 100`）、模糊查询(`k=like`)、比较、排序。

- 查询速度是`O(1)`，比B+树的`O(logn)`要快。

### 1.5 索引使用

#### 前缀索引

> 索引的选择性是指：不重复的索引值和数据表记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。

有时候需要索引很长的字符列，这会让索引变得大且慢。解决方法是：**可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。**

- 对于 BLOB/TEXT/VARCHAR 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。

- 要选择足够长的前缀以保证较高的选择性，同时又不能太长（节约空间）。

#### 聚簇索引

> 一般是主键上的索引(只有一个)，叶子节点存储一整行数据信息，查询速度快，维护代价很高

![聚簇索引](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220307193120.png)

 **InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行**。若没有定义主键，InnoDB 会隐式定义一个主键来作为聚簇索引。**聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快**。因为无法同时把数据行存放在两个不同的地方，所以**一个表只能有一个聚簇索引**。

#### 非聚簇索引

> 不一定是主键上的索引(可以有多个)，叶子节点只存储主键信息

![非聚簇索引](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220307193142.png)

需要二次查询，在非聚簇索引上检索到主键后，还要继续在聚簇索引上查找，IO次数比聚簇索引要多。

####  覆盖索引

> 辅助索引中能直接获取的数据，不需要查询聚簇索引

#### 联合索引

> 根据最左匹配原则，对表上的多个列进行索引

类比有“姓-名”电话簿，使用联合索引，先按照姓排序的基础上，名也是“相对”排好序的。

```sql
where 姓=“x”                →可以命中索引
where 名="xx"               →不能命中索引
where 姓=“x” and 名="xx"    →可以命中索引
where 名="xx" and 姓=“x”    →可以命中索引(因为mysql会自动优化)
```

#### = 和 in 可以乱序

> **不需要考虑=、in 等的顺序**，Mysql 会自动优化这些条件的顺序，以匹配尽可能多的索引列。

例子：如有索引(a, b, c, d)，查询条件 c > 3 and b = 2 and a = 1 and d < 4 与 a = 1 and c > 3 and b = 2 and d < 4 等顺序都是可以的，MySQL 会自动优化为 a = 1 and b = 2 and c > 3 and d < 4，依次命中 a、b、c。

## 二、事务

### 2.1 事务的基本特性

> 一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易。

![ACID](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220307233721.png)

- A原子性：事务是最小执行单位，事务里面的操作要么都执行成功，要么都执行失败。
- C一致性：事务执行前后，数据是保持一致的。
- I隔离性：事务执行的过程中，不允许被其他事务所干扰。
- D持久性：一个事务被提交以后，它对数据库的操作是持久的。

### 并发一致性问题

>  产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

- **丢失修改**：两个事务先后对一个数据做修改，数据被覆盖

- **脏读**：一个事务访问了一个数据，并做了修改还未提交(可能回滚) ｜ 另外一个事务访问了这个数据并使用了它
- **不可重复读**：一个事务内多次读同一数据 ｜ 另一个事务在第一个事务多次访问之间做了数据修改    → 导致两次的读取不一致
- **幻读**：一个事务内多次读同一数据  ｜ 另一个事务在第一个事务多次访问之间做了数据插入删除       → 导致两次读取多/少了一些记录

### 隔离级别

- **`未提交读`**：事务中的修改，即使没有提交，对其它事务也是可见的。
- **`提交读（READ COMMITTED）`**：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
- **`重复读（REPEATABLE READ）`**：保证在同一个事务中多次读取同样数据的结果是一样的。
- **`串行化（SERIALIXABLE）`**：强制事务串行执行。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :------: | :--: | :--------: | :--: |
| 未提交读 |  ❌   |     ❌      |  ❌   |
|  提交读  |  ✔️   |     ❌      |  ❌   |
| 可重复读 |  ✔️   |     ✔️      |  ❌   |
| 可串行化 |  ✔️   |     ✔️      |  ✔️   |

## 三、范式

![范式](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220307235723.png)

- 第一范式

    > 属性不可分，确保每列保持原子性。

    例如：把地址拆分成省份、城市、详细地址三列。

- 第二范式 (2NF)

    > 确保表中的每列都和主键相关。

    多对多的关系放在一张表里，拆开三张表。

- 第三范式（3NF）

    > 确保每列都和主键列直接相关,而不是间接相关

    多对一的关系放在一张表里，拆开两张表，留下外键。

## 四、存储引擎

> Mysql 有多种存储引擎，**不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在 Mysql 服务层统一处理的**。

| 类别         | MyISAM                                                    | InnoDB                                 |
| ------------ | --------------------------------------------------------- | -------------------------------------- |
| 支持事务     | 不支持事务，也不支持行级锁和外键。                        | 支持事务，并提供了行级锁和外键的约束。 |
| 索引类型     | 非聚簇索引                                                | 聚簇索引                               |
| 是否记录行数 | 记录                                                      | 不记录                                 |
| 适用范围     | 适合做读取非常多、Count计算、不需要事务、对表修改少的场景 | 用于增删改比较多，需要事务支持的场景   |



