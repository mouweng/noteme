# 关系型数据库面试题

- [DB-TUTORIAL（关系型数据库面试题）](https://dunwu.github.io/db-tutorial/sql/common/sql-interview.html#%E4%B8%80%E3%80%81%E7%B4%A2%E5%BC%95%E5%92%8C%E7%BA%A6%E6%9D%9F)

## 一、索引

> 索引是对数据库表中一或多个列的值进行排序的结构，是帮助数据库高效查询数据的数据结构。

### 1.1 索引的优缺点

- 优点：加速查询、排序、分组的速度；
- 缺点：索引需要占用额外的物理空间；写操作会更新索引导致速度减慢；太多的索引会增加查询优化器的选择时间；

### 1.2 索引使用原则

✔ 什么情况**适用**索引：

- 表经常进行 `SELECT` 操作；
- 表的数据量比较大；
- 列名经常出现在 `WHERE` 或连接（`JOIN`）条件中
- 外键要建立索引
- 增大索引选择性：索引应该建立在区分度高的字段上（比如性别字段选择性很低）

❌ 什么情况**不适用**索引：

- **频繁写操作**（ `INSERT`/`UPDATE`/`DELETE` ）- 需要更新索引空间；
- **非常小的表**：直接全表扫描更高效；
- 列名不经常出现在 `WHERE` 或连接（`JOIN`）条件中 - 索引就会经常不命中，没有意义，还增加空间开销。
- 对于特大型表，建立和使用索引的代价将随之增长。可以考虑使用分区技术或 Nosql。
- 避免重复索引，如果已经有a索引，现在要加（a,b）索引，没必要加，在原先基础上修改。

### 1.3 索引的类型

> 从物理存储上划分

- 聚簇索引

一般是主键上的索引(只有一个)，叶子节点存储一整行数据信息，维护代价很高。查询效率高，不需要二次查询。

- 非聚簇索引（辅助索引）

不一定是主键上的索引(可以有多个)，叶子节点只存储主键信息。需要二次查询，在非聚簇索引上检索到主键后，还要继续在聚簇索引上查找，IO次数比聚簇索引要多。

> 实现方式来划分

- B+树索引

B+树是大多数存储引擎的默认索引类型，可以用作范围查询、模糊查询、比较、排序。

- 哈希索引

哈希索引使用Hash表来作为底层结构，不可以用作范围查询、模糊查询、比较、排序，查询速度比较快O(1)，而B+树是O(logn)，在InnoDB存储引擎中“自适应哈希索引“功能，当某个值被频繁索引会在B+树索引的基础上建立一个Hash索引。

### 1.4 索引的数据结构

#### B+树

> 是为磁盘存储设计的一种平衡多叉查找树，平衡因子为0。

![B+树](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220307190228.png)

- 特性
    - 非叶子节点不存储数据，叶子节点数据用链表连接，按照key从左到右排列
- **操作**
    - 查找：在每个节点上进行二分查找，找到key所在的指针，递归直至找到叶子节点
    - 插入/删除/更改：会破坏树的平衡性，在插入删除后，要重新维护B+树（分裂、合并、旋转），开销大
- 对比B树优势
    - 查询性能稳定，所有查询都要找到叶子节点
    - 叶子节点有链表相连，便于范围查询和排序
    - 非叶子节点只存储主键，单一节点存储的元素更多，更矮胖，查询I/O次数减少
- 对比红黑树/AVL树的优势
    - B+树相对于二叉树更加矮胖，有更少的IO次数

#### 哈希

> 哈希索引使用Hash表作为底层结构。

- 只能用作等值查询，不可以用作范围查询（`WHERE price > 100`）、模糊查询(`k=like`)、比较、排序。

- 查询速度是`O(1)`，比B+树的`O(logn)`要快。

#### 全文索引

> 用于查找文本中的关键词，而不是直接比较是否相等。

全文索引配合 `match against` 操作使用。全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。MyISAM 存储引擎支持全文索引。

#### 空间数据索引

> MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

### 1.5 索引使用

#### 前缀索引

> 索引的选择性是指：不重复的索引值和数据表记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。

有时候需要索引很长的字符列，这会让索引变得大且慢。解决方法是：**可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。**

- 对于 BLOB/TEXT/VARCHAR 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。

- 要选择足够长的前缀以保证较高的选择性，同时又不能太长（节约空间）。

#### 聚簇索引

> 一般是主键上的索引(只有一个)，叶子节点存储一整行数据信息，查询速度快，维护代价很高

![聚簇索引](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220307193120.png)

 **InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行**。若没有定义主键，InnoDB 会隐式定义一个主键来作为聚簇索引。**聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快**。因为无法同时把数据行存放在两个不同的地方，所以**一个表只能有一个聚簇索引**。

#### 非聚簇索引

> 不一定是主键上的索引(可以有多个)，叶子节点只存储主键信息

![非聚簇索引](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220307193142.png)

需要二次查询，在非聚簇索引上检索到主键后，还要继续在聚簇索引上查找，IO次数比聚簇索引要多。

####  覆盖索引

> 辅助索引中能直接获取的数据，不需要查询聚簇索引

#### 联合索引

> 根据最左匹配原则，对表上的多个列进行索引

类比有“姓-名”电话簿，使用联合索引，先按照姓排序的基础上，名也是“相对”排好序的。

```sql
where 姓=“x”                →可以命中索引
where 名="xx"               →不能命中索引
where 姓=“x” and 名="xx"    →可以命中索引
where 名="xx" and 姓=“x”    →可以命中索引(因为mysql会自动优化)
```

#### = 和 in 可以乱序

> **不需要考虑=、in 等的顺序**，Mysql 会自动优化这些条件的顺序，以匹配尽可能多的索引列。

例子：如有索引(a, b, c, d)，查询条件 c > 3 and b = 2 and a = 1 and d < 4 与 a = 1 and c > 3 and b = 2 and d < 4 等顺序都是可以的，MySQL 会自动优化为 a = 1 and b = 2 and c > 3 and d < 4，依次命中 a、b、c。

## 二、事务

### 2.1 事务的基本特性

> 一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易。

![ACID](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220307233721.png)

- A原子性：事务是最小执行单位，事务里面的操作要么都执行成功，要么都执行失败。
- C一致性：事务执行前后，数据是保持一致的。
- I隔离性：事务执行的过程中，不允许被其他事务所干扰。
- D持久性：一个事务被提交以后，它对数据库的操作是持久的。

### 并发一致性问题

>  产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

- **丢失修改**：两个事务先后对一个数据做修改，数据被覆盖

- **脏读**：一个事务访问了一个数据，并做了修改还未提交(可能回滚) ｜ 另外一个事务访问了这个数据并使用了它
- **不可重复读**：一个事务内多次读同一数据 ｜ 另一个事务在第一个事务多次访问之间做了数据修改    → 导致两次的读取不一致
- **幻读**：一个事务内多次读同一数据  ｜ 另一个事务在第一个事务多次访问之间做了数据插入删除       → 导致两次读取多/少了一些记录

### 隔离级别

- **`读未提交`**：事务中的修改，即使没有提交，对其它事务也是可见的。
- **`读已提交（READ COMMITTED）`**：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
- **`可重复读（REPEATABLE READ）`**：保证在同一个事务中多次读取同样数据的结果是一样的。
- **`串行化（SERIALIXABLE）`**：强制事务串行执行。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :------: | :--: | :--------: | :--: |
| 未提交读 |  ❌   |     ❌      |  ❌   |
|  提交读  |  ✔️   |     ❌      |  ❌   |
| 可重复读 |  ✔️   |     ✔️      |  ❌   |
| 可串行化 |  ✔️   |     ✔️      |  ✔️   |

## 三、范式

![范式](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220307235723.png)

- 第一范式

    > 属性不可分，确保每列保持原子性。

    例如：把地址拆分成省份、城市、详细地址三列。

- 第二范式 (2NF)

    > 确保表中的每列都和主键相关。

    多对多的关系放在一张表里，拆开三张表。

- 第三范式（3NF）

    > 确保每列都和主键列直接相关,而不是间接相关

    多对一的关系放在一张表里，拆开两张表，留下外键。

## 四、存储引擎

> Mysql 有多种存储引擎，**不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在 Mysql 服务层统一处理的**。

| 类别         | MyISAM                                                    | InnoDB                                 |
| ------------ | --------------------------------------------------------- | -------------------------------------- |
| 支持事务     | 不支持事务，也不支持行级锁和外键。                        | 支持事务，并提供了行级锁和外键的约束。 |
| 索引类型     | 非聚簇索引                                                | 聚簇索引                               |
| 是否记录行数 | 记录                                                      | 不记录                                 |
| 适用范围     | 适合做读取非常多、Count计算、不需要事务、对表修改少的场景 | 用于增删改比较多，需要事务支持的场景   |

## 五、分库分表

> 分库分表的基本思想就是：把原本完整的数据切分成多个部分，放到不同的数据库或表上。分库分表一定是为了支撑 **高并发、数据量大**两个问题的。

### 垂直切分

> 垂直切分是**把一个有很多字段的表给拆分成多个表，或者是多个库上去**。

一般来说，会 **将较少的、访问频率较高的字段放到一个表里去**，然后 **将较多的、访问频率较低的字段放到另外一个表里去**。因为数据库是有缓存的，访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。

![垂直切分](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220309134359.png)

一般来说，满足下面的条件就可以考虑扩容了：

- Mysql 单库超过 5000 万条记录，Oracle 单库超过 1 亿条记录，DB 压力就很大。
- 单库超过每秒 2000 个并发时，而一个健康的单库最好保持在每秒 1000 个并发左右，不要太大。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

### 水平切分

> **水平切分** 又称为 **Sharding**，它是将同一个表中的记录拆分到多个结构相同的表中。当 **单表数据量太大** 时，会极大影响 **SQL 执行的性能** 。分表是将原来一张表的数据分布到数据库集群的不同节点上，从而缓解单点的压力。

![水平切分](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220309135330.png)

一般来说，**单表有 200 万条数据** 的时候，性能就会相对差一些了，需要考虑分表了。但是，这也要视具体情况而定，可能是 100 万条，也可能是 500 万条，SQL 越复杂，就最好让单表行数越少。

#### 切分的策略

- 哈希取模：`hash(key) % N` 或 `id % N`
    - 优点：可以平均分配每个库的数据量和请求压力（负载均衡）。
    - 缺点：扩容麻烦，需要数据迁移。
- 范围：可以按照 ID 或时间划分范围。
    - 优点：扩容简单。
    - 缺点：这种策略容易产生热点问题。
- 映射表：使用单独的一个数据库来存储映射关系。
    - 优点：扩容简单，可以解决分布式 ID 问题。
    - 缺点：存储映射关系的数据库也可能成为性能瓶颈，且一旦宕机，分库分表的数据库就无法工作。所以不建议使用这种策略。

### 分库分表的问题

#### 分布式 ID生成策略

一些常见的主键生成策略：

- 使用全局唯一 ID：GUID。
- 为每个分片指定一个 ID 范围。
- 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)。

#### 分布式事务

方案一：使用数据库事务

- 优点：交由数据库管理，简单有效
- 缺点：性能代价高，特别是 shard 越来越多时

方案二：由应用程序和数据库共同控制

- 原理：将一个跨多个数据库的分布式事务分拆成多个仅处于单个数据库上面的小事务，并通过应用程序来总控各个小事务。
- 优点：性能上有优势
- 缺点：需要应用程序在事务控制上做灵活设计。如果使用了 spring 的事务管理，改动起来会面临一定的困难。

#### 跨节点 Join

只要是进行切分，跨节点 Join 的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。**在第一次查询的结果集中找出关联数据的 id，根据这些 id 发起第二次请求得到关联数据。**

#### 跨节点的 count,order by,group by 以及聚合函数

与解决跨节点 join 问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和 join 不同的是每个节点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。

## 六、主从复制

> 当主数据库（master）的数据发生变化时，变化会实时同步到从数据库（slave）。主服务器负责数据修改，从服务器负责数据读取，从服务器可以使用MyISAM，提升查询性能。

![主从复制](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220309140524.png)

#### master

- **`binlog dump线程`**：master数据库发生增删改事件时，数据库会把事件写进binlog中，dump线程会将相应的binlog内容发送给slave。

#### slave

- **`I/O线程`**：I/O线程接受dump线程发送来的内容，并记录到本地的relay log。
- **`SQL线程`**：读取本地的relay log，并根据relay log的内容对数据库做相应的操作

#### binlog日志格式

> binlog有三种格式：Statement、Row以及Mixed。

- `Statement`：每一条会修改数据的sql都会记录在binlog中。但是一些存储过程、函数的调用无法被正确复制的问题。
- `Row`：记录下每一行数据修改的细节。但是产生大量的日志内容。
- `Mixed`：Statement与Row的结合。**一般的语句修改使用statment格式保存binlog，一些存储过程、函数的调用使用Row格式**。

##  七、SQL优化

- [Mysql 性能优化](https://dunwu.github.io/db-tutorial/sql/mysql/mysql-optimization.html#_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96)

> SQL 优化是数据库优化的最常见、最初级手段。
>
> 在执行 SQL 语句，语句中字段的顺序、查询策略等都可能会影响到 SQL 的执行性能。

### 执行计划EXPLAIN

> 使用执行计划 `EXPLAIN` 用来分析 `SELECT` 查询效率，开发人员可以通过分析 `EXPLAIN` 结果来优化查询语句。

比较重要的字段有：

- `select_type` - 查询类型，有简单查询、联合查询、子查询等
- `key` - 使用的索引
- `rows` - 扫描的行数

详细见：[MySQL 性能优化神器 Explain 使用分析](https://segmentfault.com/a/1190000008131735)

### 访问数据优化

- **只返回必要的列** - 不要查询不需要的列，尽量避免使用 `SELECT *` 语句。
- **只返回必要的行** - 使用 `WHERE` 语句进行查询过滤，有时候也需要使用 `LIMIT` 语句来限制返回的数据。
- **缓存重复查询的数据** - 使用缓存可以避免在数据库中进行查询，特别要查询的数据经常被重复查询，缓存可以带来的查询性能提升将会是非常明显的。
- **使用索引来覆盖查询**（即 `WHERE` 后的过滤查询字段最好是索引字段）。

### 重构查询方式

将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有：

- **缓存更高效**。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
- 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而**减少冗余记录的查询**。
- **减少锁竞争**；
- **在应用层进行连接，可以更容易对数据库进行拆分**，从而更容易做到高性能和可扩展。
- **查询本身效率也可能会有所提升**。例如下面的例子中，使用 `IN()` 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。

```sql
SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
```

### SQL 语句细节

#### 1.选择最有效率的表名顺序

数据库按照**从右到左的顺序处理 FROM 子句中的表名，FROM 子句中写在最后的表将被最先处理**。

- 如果多个表是完全**无关系**的话，将记录和列名最少的表，写在最后，然后依次类推。也就是说：**选择记录条数最少的表放在最后**。
- 如果多个表是**有关系**的话，将引用最多的表，放在最后，然后依次类推。也就是说：**被其他表所引用的表放在最后**。

例如：查询员工的编号，姓名，工资，工资等级，部门名。**emp 表被引用得最多，记录数也是最多，因此放在 form 字句的最后面**。

```sql
select emp.empno,emp.ename,emp.sal,salgrade.grade,dept.dname
from salgrade,dept,emp
where (emp.deptno = dept.deptno) and (emp.sal between salgrade.losal and salgrade.hisal)
```

#### 2.WHERE 子句中的连接顺序

数据库按照**从右到左的顺序解析 `WHERE` 子句**。因此，**表之间的连接必须写在其他 WHERE 条件的左边**，那些**可以过滤掉最大数量记录的条件必须写在 WHERE 子句的之右**。**emp.sal 可以过滤多条记录，写在 WHERE 字句的最右边**

```sql
select emp.empno,emp.ename,emp.sal,dept.dname
from dept,emp
where (emp.deptno = dept.deptno) and (emp.sal > 1500)
```

#### 3.用 TRUNCATE 替代 DELETE

如果需要**清空所有表记录**，使用 TRUNCATE 比 DELETE 执行效率高：**DELETE 是一条一条记录的删除，而 Truncate 是将整个表删除，仅保留表结构**。

#### 4.使用内部函数提高 SQL 效率

例如使用 mysql 的 concat() 函数会比使用 `||` 拼接速度快，因为 concat() 函数已经被 mysql 优化过了。

#### 5.使用表或列的别名

如果表或列的名称太长了，使用一些简短的别名也能稍微提高一些 SQL 的性能。毕竟要扫描的字符长度就变少了。

#### 6.SQL 关键字大写

我们在编写 SQL 的时候，官方推荐的是使用大写来写关键字，**因为 Oracle 服务器总是先将小写字母转成大写后，才执行**

#### 7.用 `>=` 替代 `>`

❌ 低效方式：

```sql
-- 首先定位到DEPTNO=3的记录并且扫描到第一个DEPT大于3的记录
SELECT * FROM EMP WHERE DEPTNO > 3
```

✔ 高效方式：

```sql
-- 直接跳到第一个DEPT等于4的记录
SELECT * FROM EMP WHERE DEPTNO >= 4
```

#### 8.用 IN 替代 OR

❌ 低效方式：

```sql
select * from emp where sal = 1500 or sal = 3000 or sal = 800;
```

✔ 高效方式：

```sql
select * from emp where sal in (1500,3000,800);
```

#### 9.总是使用索引的第一个列

如果索引是建立在多个列上，只有在它的第一个列被 WHERE 子句引用时，优化器才会选择使用该索引。 当只引用索引的第二个列时，不引用索引的第一个列时，优化器使用了全表扫描而忽略了索引

```sql
create index emp_sal_job_idex
on emp(sal,job);
----------------------------------
select *
from emp
where job != 'SALES';
```

## 八、Mysql数据类型

### 8.1 整型

> `TINYINT` `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`分别使用 `8`, `16`, `24`, `32`, `64` 位存储空间，一般情况下越小的列越好。

**`UNSIGNED` 表示不允许负值，大致可以使正数的上限提高一倍**。

`INT(11)` 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

### 8.2 浮点型

> `FLOAT` 和 `DOUBLE` 为浮点类型。

`DECIMAL` 类型主要用于精确计算，代价较高，应该尽量只在对小数进行精确计算时才使用 `DECIMAL` ——例如存储财务数据。数据量比较大的时候，可以使用 `BIGINT` 代替 `DECIMAL`。

`FLOAT`、`DOUBLE` 和 `DECIMAL` 都可以指定列宽，例如 `DECIMAL(18, 9)` 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

### 8.3 字符串

> 主要有 `CHAR` 和 `VARCHAR` 两种类型，一种是定长的，一种是变长的。

**`VARCHAR` 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长**。当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

`VARCHAR` 会保留字符串末尾的空格，而 `CHAR` 会删除。c

### 8.4 时间和日期

> MySQL 提供了两种相似的日期时间类型：`DATATIME` 和 `TIMESTAMP`。

`DATATIME`能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。它与时区无关。

`TIMESTAMP`和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。

应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。

### 8.5 BLOB 和 TEXT

> `BLOB` 和 `TEXT` 都是为了存储大的数据而设计，前者存储二进制数据，后者存储字符串数据。

- `BLOB`有`TINYBLOB`（最大 255B），`BLOB`（最大 64KB）， `MediumBlob`（最大 16MB），`LONGBLOB`（最大 4GB）
- `TEXT`有`TINYTEXT`（最大 255B），`TEXT`（最大 64KB），`MEDIUMTEXT`（最大 16MB），`LONGTEXT`（最大 4GB）

不能对 `BLOB` 和 `TEXT` 类型的全部内容进行排序、索引。

## 九、锁

