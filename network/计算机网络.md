## 计算机网络

## 常见的应用层协议

| 应用程序 | FTP   | TELNET | SMTP | POP3 | HTTP | DNS  | TFTP |
| -------- | ----- | ------ | ---- | ---- | ---- | ---- | ---- |
| 协议     | TCP   | TCP    | TCP  | TCP  | TCP  | UDP  | UDP  |
| 端口号   | 20/21 | 23     | 25   | 110  | 80   | 53   | 69   |

## OSI模型

![OSI七层模型](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220301195717.webp)

## 地址解析协议ARP

> ARP协议是实现从IP地址到MAC地址的转换。

![ARP](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220301202157.jpg)

当路由器A要传输信息给路由器B时，这是IP报文只有IP地址，所以要查询B的MAC地址。

- A中会有一个ARP高速缓存，如果里面有B的地址，则直接找到；

- 如果没有，则会发送ARP请求广播，主机B收到广播后会发送响应报文给A，A把它写到自己的高速缓存中。

![ARP广播](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220301202219.png)

## TCP和UDP的区别

|          | UDP                                                          | TCP                                                          |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 连接类型 | 无连接，提供最大可能交付                                     | 有链连接，提供可靠交付                                       |
| 拥塞控制 | 无                                                           | 有                                                           |
| 流量控制 | 无                                                           | 有                                                           |
| 面向对象 | 面向报文（对于应用层传下来的报文不合并也不拆分，只是添加 UDP 首部） | 面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块） |
| 其他     | 支持一对一、一对多、多对一和多对多的交互通信                 | 每一条 TCP 连接只能是点对点的                                |
| 使用场景 | 即时通信、音视频传输                                         | 文件传输、发送和接收邮件、远程登录等场景。                   |
| 协议     | DNS                                                          | HTTP、POP3、STMP、Telnet、FTP                                |

## TCP可靠传输

- 停止等待协议：每发送完一个分组就停止，先等待对方确认再发送
- 连续ARQ协议：滑动窗口，收到好几个分组，对顺序到达的最后一个分组进行确认

## TCP拥塞控制

### 流量控制和拥塞控制的区别

- 流量控制是通过设置确认报文的窗口字段而告知对方，用来控制发送方的窗口大小。
- 拥塞控制和流量控制的区别是流量控制是控制的接收方，拥塞控制控制的整个网络。

### 拥塞控制要点

拥塞控制的四个要点是：慢开始、拥塞避免、快重传和快恢复。

![拥塞控制](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220301203124.png)

- **慢开始和拥塞避免**

指的是每次从一个报文开始发，只要收到回复报文，下一次发送的报文数目就加倍，1，2，4，8...知道到达设定的阈值s，开始进行拥塞避免，每次只增加1个报文，直到发生超时，则发送报文数目降到1，阈值为原先的1/2，重新进行慢开始。

- **快重传和快恢复**

在拥塞避免发生超时时，连续收到3个ack重复确认，则代表不是网络发生拥塞，而是报文丢失，这时候报文直接从当前报文数量/2开始增长，这叫快重传和快恢复

## TCP三次握手和四次挥手

### 三次握手

![三次握手过程](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220301203643.png)

- 为什么要采用三次握手？

> 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

采用三次握手是为了防止失效的连接请求报文段突然又传送到主机S，因而产生错误。主机C发出的连接请求没有收到主机S的确认，于是经过一段时间后，主机C又重新向主机S发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机C第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机S，主机S以为是主机C又发起的新连接，于是主机S同意连接，并向主机C发回确认，但是此时主机C根本不会理会，主机S就一直在等待主机C发送数据，导致主机S的资源浪费。

### 四次挥手

![四次挥手过程](https://cdn.jsdelivr.net/gh/mouweng/FigureBed/img/20220301203708.png)

- 为什么连接的时候是三次握手，关闭的时候却是四次握手？

> 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

因为在请求连接的时候，C和S之间是没有发生数据传输的，所以C发送请求报文时，S可以同时恢复一个SYN和ACK报文，以表示确认收到和同意连接。

但是在断开连接的时候，当C发送FIN终止报文的时候，S收到FIN终止报文，但是S可能还有数据没有传输完，所以先回复一个ACK，然后等数据传输完毕，再回复FIN和ACK，所以需要四次挥手

- 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

因为最后一次ACK发送出去之后，为了确保对方能够收到，因为报文一去已回最大的生存时间是2MSL，如果在这时间内没有收到请求，则代表对方收到了；如果对方没收到，则在2MSL里面会收到继续收到对方的终止连接报文。